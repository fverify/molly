#lang racket

;; command-line usage:
;; cat <fp-formula.fml> | ./parser-generator <config-file.cfg> <arith-var-file.txt>
;; This program generates the python parser code that populates internal data structures of the code implementing
;; the lazy real arithmetic encoding approach for deciding floating-point formulas. The python file generated by 
;; this program is imported by the aforementioned decision procedure. This program also outputs the variables 
;; occurring in <fp-formula.fml> in <arith-var-file.txt>

;; required external libraries
(require mzlib/string)
(require redex/reduction-semantics)

;; global variables section;
;; initilaizing the list of objects for each of the classes in the decision procedure file (these list will 
;; contain names (strings) of the objects though
(define propexp-list '())
(define prop-list '())
(define relexp-list '())
(define arithexp-list '())
(define var-list '())
(define const-list '())
(define num-list '())
;(define var-val-map '((x ("Fraction(8,1)" "mpfr(Fraction(8,1))")) (y ("Fraction(3,1)" "mpfr(Fraction(3,1))"))));'())
;((x ("Fraction(8,1)" "mpfr(Fraction(8,1))")) (y ("Fraction(3,1)" "mpfr(Fraction(3,1))")))
(define A_INDEX 1)

(define IMPORT-STMTS "#IMPORTS\nimport gmpy2\nfrom solve_rp import *\n")
(define GD_STMT "gd = GlobalData()\n")
(define GMPY2-GET-CONTEXT "\n#getting current gmpy2 context\nctx = gmpy2.get_context()\n")

;; utility functions section
(define (list->string l)
  (if (empty? l)
      ""
      (string-append (symbol->string (first l)) " "(list->string (rest l)))))

;; helper functions section
(define (get-val-from-map var map)
  (if (empty? map)
      (list "" "")
      (if (equal? var (first (first map)))
          (second (first map))
          (get-val-from-map var (rest map)))))

(define (create-map-helper list-of-rows)
  (if (empty? list-of-rows)
      '()
      (let* ((row-as-list (string-split (first list-of-rows)))
             (var (string->symbol (first row-as-list)))
             (val (list (second row-as-list) (third row-as-list))))
        (cons (list var val) (create-map-helper (rest list-of-rows))))))

;;
(define (get-declaration-set-var var)
  (let* ((already-present (member var var-list))
         (dummy (if already-present
                    ""
                    (set! var-list (cons var var-list))))
         ;(val (get-val-from-map var var-val-map))
         ;(fp-val-str (second val))
         ;(real-val-str (first val))
         (var-name (symbol->string var)))
    (if already-present
        (list var-name "")
        (list var-name (string-append var-name " = Var(gd,'"
                                      var-name  "'" ;"',"
                                      ;fp-val-str ","
                                      ;real-val-str
                                      ")\n")))))

(define (const-present? const const-list)
  (if (empty? const-list)
      #f
      (if (equal? const (second (first const-list)))
          (first const-list)
          (const-present? const (rest const-list)))))

(define (get-declaration-set-const const)
  (let* ((already-present (const-present? const const-list))
         (const-name (if already-present
                         (first already-present)
                         (let* ((name (string-append "const" (number->string (length const-list))))
                                (dummy (set! const-list (cons (list name const) const-list))))
                           name)))
         ;; The following two lines commented on Oct 11, 2014 for consistency
         ;; Any constants in input file are forced to a float (acc. to mpfr's mode)
         ;; /**including the one that gets assigned to the real value of the constant**/ 
         ;;(real-val-str (string-append "Fraction('" (number->string const) "')"))
         ;;(fp-val-str (string-append "mpfr(" real-val-str ")")))
         (fp-val-str (string-append "mpfr('" (number->string const) "')"))
         (real-val-str (string-append "Fraction(str(" fp-val-str "))")))
    (if already-present
        (list const-name "")
        (list const-name (string-append const-name " = Const("
                                        fp-val-str ","
                                        real-val-str
                                        ",gd,'" const-name "')\n")))))

(define (get-declaration-set var-const)
  (if (symbol? var-const)
      (get-declaration-set-var var-const);;it is a variable
      (get-declaration-set-const var-const)))


;(define (create-map var-val)
 ; (let ((list-of-rows (string-split var-val "\n")))
  ;  (create-map-helper list-of-rows)))
;; OUTPUT FOR SAMPLE FILE: '((x ("Fraction(8,1)" "mpfr(Fraction(8,1))")) (y ("Fraction(3,1)" "mpfr(Fraction(3,1))")))

(define (get-gmpy2-rounding-mode rnd-mode)
  (cond 
    [(equal? "round-to-negative" rnd-mode) "gmpy2.RoundDown"]
    [(equal? "round-to-positive" rnd-mode) "gmpy2.RoundUp"]
    [(equal? "round-to-zero" rnd-mode) "gmpy2.RoundToZero"]
    [(equal? "round-to-nearest-away" rnd-mode) "gmpy2.RoundAwayZero"] ;;The one that gmpy2 uses is always round away from zero, not nearest and ties resolved to away
    [(equal? "round-to-nearest-even" rnd-mode) "gmpy2.RoundToNearest"];;
    [(equal? "round-to-nearest-simple" rnd-mode) "gmpy2.RoundToNearest"];;THIS IS A HACK (as no python implementation for this rounding mode is available, for temporary use only
    [true "error"]))

(define (generate-gmpy2-context rnd-mode precision)
  (let* ((gmpy2-precision (number->string (+ 1 precision)))
         (gmpy2-rounding-mode (get-gmpy2-rounding-mode rnd-mode))
         (gmpy2-set-stmt (string-append "ctx1 = set_prec_mode(" gmpy2-precision ","  gmpy2-rounding-mode ", ctx)\n")))
    (string-append GMPY2-GET-CONTEXT gmpy2-set-stmt)))

(define (arith-op? op)
  (or (equal? '+ op) (equal? '- op) (equal? '* op) (equal? '/ op)))

(define (arith-exp? s-expr)
  (arith-op? (first s-expr)))

(define (rel-op? op)
  (or (equal? '< op) (equal? '<= op) (equal? '> op) (equal? '>= op) (equal? '= op)))

(define (rel-exp? s-expr)
  (rel-op? (first s-expr)))

(define (prop? s-expr)
  (rel-exp? s-expr))

(define (unary-boolean-op? op)
  (equal? 'not op))

(define (binary-boolean-op? op)
  (or (equal? 'and op) (equal? 'or op)))

(define (boolean-op? op)
  (or (binary-boolean-op? op) (unary-boolean-op? op)))

(define (prop-exp? s-expr)
  (boolean-op? (first s-expr)))

;; x = Var("x",0,mpfr(Fraction(8,1)),Fraction(8,1),3)

;; main code section
;; generates code that calls constructor Var/Const for opnd1 as appropriate
;(define (declare-var-const opnd1)
;  (let* ((var? (symbol? opnd1));; checks if opnd1 is a Var or a Const
;         (class-name (if var?;; sets class/constructor name appropriately
;                         "Var"
;                         "Const"))
;         (val (if var? 
;                  (get-val-from-map opnd1 var-val-map);; gets the row (list <real-val> <fp-val>) from the map
;                  (list (string-append "mpfr(Fraction('" (number->string opnd1) "'))")
;                        (string-append "Fraction('" (number->string opnd1) "')"))))
;         (fp-val-str (second val))
;         (real-val-str (first val)))
;    (string-append (symbol->string opnd1) " = " class-name "("
;                   (symbol->string opnd1) ","
;                   fp-val-str ","
;                   real-val-str
;                   ")\n")))

;; case when operands opnd1 and opnd2 are either Var or Const
(define (generate-code-arith-exp-helper1 op opnd1 opnd2 result)
  (let* ((name-decl1 (get-declaration-set opnd1))
         (opnd1-name  (first name-decl1))
         (decl1 (second name-decl1))
         (name-decl2 (get-declaration-set opnd2))
         (opnd2-name  (first name-decl2))
         (decl2 (second name-decl2))
         (dummy5 (set! A_INDEX (+ A_INDEX 1))))
    (string-append decl1
                   decl2
                   (symbol->string result) " = ArithExp(" 
                   opnd1-name ",'"
                   (symbol->string op) "'," 
                   opnd2-name 
                   ",gd,'" (symbol->string result) "')\n")))

;; case when operand opnd1 is a Var/Const but opnd2 is an ArithExp 
(define (generate-code-arith-exp-helper2 op opnd1 opnd2 result)
  (let* ((name-decll (get-declaration-set opnd1))
         (opnd1-name  (first name-decll))
         (decll (second name-decll))
         (new-right-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the right exp
         (dummy (set! arithexp-list (cons new-right-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (right-code (generate-code-arith-exp opnd2 new-right-var))
         (dummy5 (set! A_INDEX (+ A_INDEX 1))))
    (string-append decll
                   right-code
                   (symbol->string result) " = ArithExp(" 
                   opnd1-name ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ",gd,'" (symbol->string result) "')\n")))

;; case when operand opnd1 is a ArithExp but opnd2 is a Var/Const
(define (generate-code-arith-exp-helper3 op opnd1 opnd2 result)
  (let* ((name-declr (get-declaration-set opnd2))
         (opnd2-name  (first name-declr))
         (declr (second name-declr))
         (new-left-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the left exp
         (dummy (set! arithexp-list (cons new-left-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (left-code (generate-code-arith-exp opnd1 new-left-var))
         (dummy5 (set! A_INDEX (+ A_INDEX 1))))
    (string-append declr
                   left-code
                   (symbol->string result) " = ArithExp(" 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   opnd2-name
                   ",gd,'" (symbol->string result) "')\n")))

;; case when both operands opnd1 and opnd2 are ArithExp
(define (generate-code-arith-exp-helper4 op opnd1 opnd2 result)
  (let* ((new-left-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the left exp
         (dummy (set! arithexp-list (cons new-left-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (new-right-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the right exp
         (dummy (set! arithexp-list (cons new-right-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (left-code (generate-code-arith-exp opnd1 new-left-var))
         (right-code (generate-code-arith-exp opnd2 new-right-var))
         (dummy5 (set! A_INDEX (+ A_INDEX 1))))
    (string-append left-code
                   right-code
                   (symbol->string result) " = ArithExp(" 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ",gd,'" (symbol->string result) "')\n")))


(define (generate-code-arith-exp s-expr result)
  (let ((op (first s-expr))
        (opnd1 (second s-expr))
        (opnd2 (third s-expr)))
    (cond
      [(and (not (list? opnd1)) (not (list? opnd2)))
       (generate-code-arith-exp-helper1 op opnd1 opnd2 result)]
      [(and (not (list? opnd1)) (list? opnd2))
       (generate-code-arith-exp-helper2 op opnd1 opnd2 result)]
      [(and (list? opnd1) (not (list? opnd2)))
       (generate-code-arith-exp-helper3 op opnd1 opnd2 result)]
      [(and (list? opnd1) (list? opnd2))
       (generate-code-arith-exp-helper4 op opnd1 opnd2 result)])))

;; case when operands opnd1 and opnd2 are either Var or Const
;; This is effectively the same as helper1 function for ArithExp, can be combined into a single function
(define (generate-code-rel-exp-helper1 op opnd1 opnd2 result)
  (let* ((name-decl1 (get-declaration-set opnd1))
         (opnd1-name  (first name-decl1))
         (decl1 (second name-decl1))
         (name-decl2 (get-declaration-set opnd2))
         (opnd2-name  (first name-decl2))
         (decl2 (second name-decl2)));;need to generate code that calls constructor Var/Const as appropriate
    (string-append decl1
                   decl2
                   (symbol->string result) " = RelExp(" 
                   opnd1-name ",'"
                   (symbol->string op) "'," 
                   opnd2-name 
                   ")\n")))

;; case when operand opnd1 is a Var/Const but opnd2 is an ArithExp
(define (generate-code-rel-exp-helper2 op opnd1 opnd2 result)
  (let* ((name-decl1 (get-declaration-set opnd1))
         (opnd1-name  (first name-decl1))
         (decl1 (second name-decl1))
         (new-right-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the right exp
         (dummy (set! arithexp-list (cons new-right-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (right-code (generate-code-arith-exp opnd2 new-right-var)))
    (string-append decl1
                   right-code
                   (symbol->string result) " = RelExp(" 
                   opnd1-name ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ")\n")))

;; case when operand opnd1 is a ArithExp but opnd2 is a Var/Const
(define (generate-code-rel-exp-helper3 op opnd1 opnd2 result)
  (let* ((name-decl2 (get-declaration-set opnd2))
         (opnd2-name  (first name-decl2))
         (decl2 (second name-decl2))
         (new-left-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the right exp
         (dummy (set! arithexp-list (cons new-left-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (left-code (generate-code-arith-exp opnd1 new-left-var)))
    (string-append decl2
                   left-code
                   (symbol->string result) " = RelExp(" 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   opnd2-name 
                   ")\n")))


;; case when both operands opnd1 and opnd2 are ArithExp
(define (generate-code-rel-exp-helper4 op opnd1 opnd2 result)
  (let* ((new-left-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the right exp
         (dummy (set! arithexp-list (cons new-left-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (new-right-var (variable-not-in arithexp-list (term arithexp)));; generates a new name for the right exp
         (dummy (set! arithexp-list (cons new-right-var arithexp-list)));; adds the newly generated name to the arithexp name list
         (left-code (generate-code-arith-exp opnd1 new-left-var))
         (right-code (generate-code-arith-exp opnd2 new-right-var)))
    (string-append left-code
                   right-code
                   (symbol->string result) " = RelExp(" 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ")\n")))

(define (generate-code-rel-exp s-expr result)
  (let ((op (first s-expr))
        (opnd1 (second s-expr))
        (opnd2 (third s-expr)))
    (cond
      [(and (not (list? opnd1)) (not (list? opnd2)))
       (generate-code-rel-exp-helper1 op opnd1 opnd2 result)]
      [(and (not (list? opnd1)) (list? opnd2))
       (generate-code-rel-exp-helper2 op opnd1 opnd2 result)
       ]
      [(and (list? opnd1) (not (list? opnd2)))
       (generate-code-rel-exp-helper3 op opnd1 opnd2 result)
       ]
      [(and (list? opnd1) (list? opnd2))
       (generate-code-rel-exp-helper4 op opnd1 opnd2 result)
       ])))

;;
;(define (generate-code-prop s-expr result relexp-var)
;  (string-append (symbol->string result) " = Prop('"
;                 (symbol->string result) "',"
;                 (symbol->string relexp-var) ",True, True)\n"))

;;
(define (generate-code-prop s-expr result)
  (let* ((relexp-var (variable-not-in relexp-list (term relexp)))
         (dummy (set! relexp-list (cons relexp-var relexp-list)))
         (rel-exp-code (generate-code-rel-exp s-expr relexp-var))
         ;(prop-code (generate-code-prop s-expr result relexp-var))
         )
    (string-append rel-exp-code
                   ;prop-code
                   (string-append (symbol->string result) " = Prop('"
                                  (symbol->string result) "',"
                                  (symbol->string relexp-var) 
                                  ;",True, True"
                                   ",gd)\n"))))



;; case when both opnd1 and opnd2 are propositions
(define (generate-code-prop-exp-helper1 op opnd1 opnd2 result)
  (let* ((new-left-var (variable-not-in prop-list (term prop)));; generates a new name for the leftt exp
         (dummy (set! prop-list (cons new-left-var prop-list)));; adds the newly generated name to the prop name list
         (new-right-var (variable-not-in prop-list (term prop)));; generates a new name for the right exp
         (dummy (set! prop-list (cons new-right-var prop-list)));; adds the newly generated name to the prop name list
         (left-code (generate-code-prop opnd1 new-left-var))
         (right-code (generate-code-prop opnd2 new-right-var)))
    (string-append left-code
                   right-code
                   (symbol->string result) " = PropExp(gd,'" 
                   (symbol->string result) "'," 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ;",True, True"
                   ")\n")))

;; opnd1 is a prop, opnd2 is a propexp
(define (generate-code-prop-exp-helper2 op opnd1 opnd2 result)
  (let* ((new-left-var (variable-not-in prop-list (term prop)));; generates a new name for the leftt exp
         (dummy (set! prop-list (cons new-left-var prop-list)));; adds the newly generated name to the prop name list
         (new-right-var (variable-not-in propexp-list (term propexp)));; generates a new name for the right exp
         (dummy (set! propexp-list (cons new-right-var propexp-list)));; adds the newly generated name to the prop name list
         (left-code (generate-code-prop opnd1 new-left-var))
         (right-code (generate-code-prop-exp opnd2 new-right-var)))
    (string-append left-code
                   right-code
                   (symbol->string result) " = PropExp(gd,'" (symbol->string result) "'," 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ;",True, True\n"
                   ")\n")))

;; opnd1 is a propexp, opnd2 is a prop
(define (generate-code-prop-exp-helper3 op opnd1 opnd2 result)
  (let* ((new-left-var (variable-not-in propexp-list (term propexp)));; generates a new name for the left exp
         (dummy (set! propexp-list (cons new-left-var propexp-list)));; adds the newly generated name to the prop name list
         (new-right-var (variable-not-in prop-list (term prop)));; generates a new name for the right exp
         (dummy (set! prop-list (cons new-right-var prop-list)));; adds the newly generated name to the prop name list
         (left-code (generate-code-prop-exp opnd1 new-left-var))
         (right-code (generate-code-prop opnd2 new-right-var)))
    (string-append left-code
                   right-code
                   (symbol->string result) " = PropExp(gd,'" (symbol->string result) "'," 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ;",True, True"
                   ")\n")))


;; opnd1 and opnd2 are both propexp
(define (generate-code-prop-exp-helper4 op opnd1 opnd2 result)
  (let* ((new-left-var (variable-not-in propexp-list (term propexp)));; generates a new name for the left exp
         (dummy (set! propexp-list (cons new-left-var propexp-list)));; adds the newly generated name to the prop name list
         (new-right-var (variable-not-in propexp-list (term propexp)));; generates a new name for the right exp
         (dummy (set! propexp-list (cons new-right-var propexp-list)));; adds the newly generated name to the prop name list
         (left-code (generate-code-prop-exp opnd1 new-left-var))
         (right-code (generate-code-prop-exp opnd2 new-right-var)))
    (string-append left-code
                   right-code
                   (symbol->string result) " = PropExp(gd,'" (symbol->string result) "'," 
                   (symbol->string new-left-var) ",'"
                   (symbol->string op) "'," 
                   (symbol->string new-right-var) 
                   ;",True, True"
                   ")\n")))

;;
(define (generate-code-prop-exp s-expr result)
  (let ((op (first s-expr))
        (opnd1 (second s-expr))
        (opnd2 (third s-expr)))
    (cond
      [(and (not (prop-exp? opnd1)) (not (prop-exp? opnd2)))
       (generate-code-prop-exp-helper1 op opnd1 opnd2 result)]
      [(and (not (prop-exp? opnd1)) (prop-exp? opnd2))
       (generate-code-prop-exp-helper2 op opnd1 opnd2 result)]
      [(and (prop-exp? opnd1) (not (prop-exp? opnd2)))
       (generate-code-prop-exp-helper3 op opnd1 opnd2 result)]
      [(and (prop-exp? opnd1) (prop-exp? opnd2))
       (generate-code-prop-exp-helper4 op opnd1 opnd2 result)])))

(define (code-generator s-expr result)
  (cond
    [(arith-exp? s-expr) (generate-code-arith-exp s-expr result)]
    [(prop? s-expr) (generate-code-prop s-expr result)]
    [(prop-exp? s-expr) (generate-code-prop-exp s-expr result)]))

;;
;(define (code-generator s-expr result)
;  (cond
;    [(arith-exp? s-expr) (generate-code-arith-exp s-expr result)]
;    [(prop? s-expr) (let* ((relexp-var (variable-not-in relexp-list (term relexp)))
;                           (dummy (set! relexp-list (cons relexp-var relexp-list)))
;                           (rel-exp-code (generate-code-rel-exp s-expr relexp-var))
;                           (prop-code (generate-code-prop s-expr result relexp-var)))
;                      (string-append rel-exp-code prop-code))]
;    [(prop-exp? s-expr) (generate-code-prop-exp s-expr result)]))


;(set! arithexp-list (append '(arithexp6 arithexp5 arithexp4 arithexp3 arithexp2 arithexp1 arithexp) arithexp-list))
;(code-generator '(+ 1 y) 'arithexp1)
;(code-generator '(+ x 1) 'arithexp2)
;(code-generator '(+ 2 1) 'arithexp3)
;(code-generator '(+ (+ 3 2) (+ 1 3)) 'arithexp4)
;(code-generator '(+ 1 (+ 1 3)) 'arithexp5)
;(code-generator '(+ (+ 1 y) 9) 'arithexp6)
;(code-generator '(+ x (+ x y)) 'arithexp2)
;(code-generator '(+ (+ y x)  x) 'arithexp3)
;(display (code-generator '(+ (+ y x) (+ x y)) 'arithexp4))
;(set! relexp-list (append '(relexp3 relexp2 relexp1 relexp) relexp-list))
;(set! prop-list (append '(prop prop1 prop2 prop3 prop4) prop-list))
;(display(code-generator '(< (+ x y) (+ y x)) 'prop))
;(display(code-generator '(< x (+ y x)) 'prop1))
;(display(code-generator '(< (+ y x) 1) 'prop2))
;(display(code-generator '(< 1 y) 'prop3))
;(display(code-generator '(< 2 (+ 1 x)) 'prop4))
;(set! propexp-list (append '(propexp1 propexp) propexp-list))
;(display (code-generator '(and (< (+ y x) y) (< x y)) 'propexp))
;(display (code-generator '(and (< (+ y x) y) (or (< x y) (> (+ y x) x))) 'propexp1))

;;
(define (top-level-code-generator s-expr)
  (let ((dummy (set! propexp-list (cons 'propexp propexp-list))))
    (if (prop? s-expr)
        (code-generator (list 'and s-expr '(< 1 2)) 'propexp); 'propexp)
        (code-generator s-expr 'propexp))))

;older one
;(define (top-level-code-generator s-expr var-val)
; (string-append "\n" (expr->string s-expr) "\n" var-val "\n" (expr->string (get-val-from-map 'x var-val-map)) (expr->string var-val-map)))

(define (parser-generator s-expr rnd-mode precision arith-var-file)
  (let* ((gmpy2-context (generate-gmpy2-context rnd-mode precision))
        (parser-body (top-level-code-generator s-expr))
        (dummy (with-output-to-file arith-var-file (lambda () (display (list->string var-list)))#:exists 'replace)))
    (string-append IMPORT-STMTS GD_STMT gmpy2-context parser-body)))

;; command-line usage:
;; <prompt>cat <fp-formula.fml> | ./parser-generator <config-file.cfg> <var-real-fp-value-assignment.asn>
;; e.g. $cat f1.fml | ./parser-generator c1.cfg var-map-f1-c1.asn
(let* ((config (file->string (vector-ref (current-command-line-arguments) 0)));; read the config file name and 
       ;; get its contents
       ;(var-val (file->string (vector-ref (current-command-line-arguments) 1)));; read file having real and fp variable
       (arith-var-file (vector-ref (current-command-line-arguments) 1))
       ;; assignments
       ;(dummy (set! var-val-map (create-map var-val)))
       (cfg-list (string-split config "\n"));; each option given on a separate line in <config-file.cfg>
       ;; is now in the list cfg-list
       (precision (string->number (first cfg-list)));; precision (#bits after radix point)
       (rnd-mode (second cfg-list));; rounding mode
       (s-expr (read-from-string (read-line)));; formula piped from the file <fp-formula.fml> stored in s-expr 
       (parser-code (parser-generator s-expr rnd-mode precision arith-var-file))
       (dummy2 (with-output-to-file "initialize2.py" (lambda () (display parser-code))#:exists 'replace)))
  (display parser-code))
